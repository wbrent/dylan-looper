#N canvas 792 357 1005 485 12;
#X obj 65 60 r perf-\$1-avg-ping;
#X obj 33 25 r loop-dur;
#X obj 33 129 -;
#X obj 65 84 t b f;
#X obj 33 403 s perf-\$1-remote-delay;
#X obj 65 180 r quack-buffering;
#X obj 65 204 * 64;
#X obj 65 288 * 2;
#X obj 65 312 t b f;
#X obj 33 369 -;
#X text 149 17 start with the duration (ms) of one loop at the current
settings;
#X text 149 97 subtract the current round-trip ping time for this performer
;
#X obj 65 238 /;
#X obj 65 262 * 1000;
#X obj 125 208 samplerate~;
#X obj 125 232 t b f;
#X text 149 261 subtract the buffering delay caused by quacktrip's
delay buffer. this value represents multiples of the block size (64
samples by default. note that this seems to refer to Pd's block size
\, not the block size chosen in the quacktrip panel). we divide by
the sampling rate and multiply by 1000 to convert to ms. finally \,
the same buffering is done on both the server and client side of the
quacktrip connection \, so we multiply this by two.;
#X text 263 138 **** Logically \, this should account for all of the
delays involved on both sides except for the Pd app's I/O delay setting
\, which should only be relevant on the client side. however \, i did
get better alignment when i only accounted for one side of the quack
buffering rather than for both the server and client. this could be
a coincidence and may have to do with the changing "fill" values shown
in the quack panel that indicate how far offset the buffered audio
is from the latest incoming block. maybe a good strategy would be to
get this information into the calculation as well., f 95;
#X connect 0 0 3 0;
#X connect 1 0 2 0;
#X connect 2 0 9 0;
#X connect 3 0 2 0;
#X connect 3 0 14 0;
#X connect 3 1 2 1;
#X connect 5 0 6 0;
#X connect 6 0 12 0;
#X connect 7 0 8 0;
#X connect 8 0 9 0;
#X connect 8 1 9 1;
#X connect 9 0 4 0;
#X connect 12 0 13 0;
#X connect 13 0 7 0;
#X connect 14 0 15 0;
#X connect 15 0 12 0;
#X connect 15 1 12 1;
